- - -
components: GlobalStyles
- - -

# 如何定制

<p class="description">You can easily customize the appearance of a MUI component.</p>

由于组件可以在不同的环境中使用，因此有几种方法可以对其进行定制。 从最狭窄到最广泛的用例，这些是：

1. [一次性定制](#1-one-off-customization)
1. [可重复使用的样式覆盖](#2-reusable-style-overrides)
1. [动态变体](#3-dynamic-variation)
1. [全局化主题变体](#4-global-theme-variation)
1. [全局 CSS 覆盖](#5-global-css-override)

## 1. 一次性定制

您可能需要为实现特定的组件而更改样式，以下有几种解决方案：

### 使用 `sx` 属性

The easiest way to add style overrides for a one-off situation is to use the [`sx` prop](/system/basics/#the-sx-prop) available on all MUI components. 下面是一个示例：

{{"demo": "pages/customization/how-to-customize/SxProp.js"}}

Next you'll see how you can use global class selectors for accessing slots inside the component. 你还将学习如何轻松识别组件中每个状态和槽位的可用类。

### 覆盖嵌套组件样式

你可以使用浏览器开发工具来确定您要覆盖的组件的插槽。 这样做可以节省你的很多时间。 The styles injected into the DOM by MUI rely on class names that [follow a simple pattern](/styles/advanced/#class-names): `[hash]-Mui[Component name]-[name of the slot]`.

⚠️ These class names can't be used as CSS selectors because they are unstable, however, MUI applies global class names using a consistent convention: `Mui[Component name]-[name of the slot]`.

让我们回到上面的演示。 如何覆写滑块的拇指图标？

<img src="/static/images/customization/dev-tools.png" alt="dev-tools" width="406" />

在本例中，样式应用的是 `.css-ae2u5c-MuiSlider-thumb`，所以组件的名称是 `Slider`，插槽的名称是 `thumb`。

你现在知道你需要针对 `.MuiSlider-thumb` 类名来覆盖拇指的外观：

{{"demo": "pages/customization/how-to-customize/DevTools.js"}}

### 用类名（class names）覆盖样式

如果你想使用类覆盖组件的样式，你可以使用每个组件上可用的 `className` 属性。 对于覆盖组件内部不同部件的样式，可以使用每个槽位可用的全局类，如前一节所述。

您可以在 [样式库互操作性](/guides/interoperability/) 指南中找到不同样式库的示例。

### State classes

组件会有一些特殊的状态，如 *hover* ，*focus* ，*disabled* 和 *selected* ，它们被一些更高的 CSS 特异性所装饰。 [优先级是一种加权](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)，它适用于给定的 CSS 声明。

In order to override the components' special states, **you need to increase specificity**. Here is an example with the _disable_ state and the Button component using a pseudo-class (`:disabled`):

```css
.Button {
  color: black;
}

/* 覆盖属性 */
.Button:disabled {
  color: white;
}
```

```jsx
<Button disabled className="Button">
```

Sometimes, you can't use a CSS pseudo-class, as the state doesn't exist in the web specification. Let's take the MenuItem component and its _selected_ state as an example. In such cases you can use a MUI equivalent of CSS pseudo-classes - **state classes**. Target the `.Mui-selected` global class name to customize the special state of the `MenuItem` component:

```css
.MenuItem {
  color: black;
}

/* 覆盖属性 */
.MenuItem.Mui-selected {
  color: blue;
}
```

```jsx
<MenuItem selected className="MenuItem">
```

#### 为什么我需要增加优先级来覆盖一个组件的状态呢？

通过一些设计，CSS 的一些特殊要求让伪类提高了优先级。 For consistency with native elements, MUI increases the specificity of its custom state classes. 这有一个重要的优点，您可以自由挑选那些想要自定义状态。

#### What custom state classes are available in MUI?

You can rely on the following [global class names](/styles/advanced/#with-material-ui-core) generated by MUI:

| 状态            | 全局类名                |
|:------------- |:------------------- |
| active        | `.Mui-active`       |
| checked       | `.Mui-checked`      |
| completed     | `.Mui-completed`    |
| disabled      | `.Mui-disabled`     |
| error         | `.Mui-error`        |
| expanded      | `.Mui-expanded`     |
| focus visible | `.Mui-focusVisible` |
| focused       | `.Mui-focused`      |
| required      | `.Mui-required`     |
| selected      | `.Mui-selected`     |

> ⚠️ Never style these state classes' names directly:

```css
/* ❌ NOT OK, impact all the components with unclear side-effects */
.Mui-error {
  color: red;
}

/* ✅ OK */
.MuiOutlinedInput-root.Mui-error {
  color: red;
}
```

## 2. 可重复使用的样式覆盖

If you find that you need the same overrides in multiple places across your application, you can use the [`styled()`](/system/styled/) utility to create a reusable component:

{{"demo": "pages/customization/how-to-customize/StyledCustomization.js", "defaultCodeOpen": true}}

With it, you have access to all of a component's props to dynamically style the component.

## 3。 动态变体

In the previous section, we learned how to override the style of a MUI component. 现在，让我们看看我们如何使动态地应用这个覆盖。 Here are four alternatives; each has its pros and cons.

### 动态 CSS

Using the `styled()` utility offers a simple way for adding dynamic styles based on props.

{{"demo": "pages/customization/how-to-customize/DynamicCSS.js", "defaultCodeOpen": false}}

> ⚠️ Note that if you are using TypeScript you will need to update the prop's types of the new component.

```tsx
import * as React from 'react';
import { styled } from '@mui/material/styles';
import Slider, { SliderProps } from '@mui/material/Slider';

interface StyledSliderProps extends SliderProps {
  success?: boolean;
}

const StyledSlider = styled(Slider, {
  shouldForwardProp: (prop) => prop !== 'success',
})<StyledSliderProps>(({ success, theme }) => ({
  ...(success &&
    {
      // the overrides added when the new prop is used
    }),
}));
```

### CSS 变量

{{"demo": "pages/customization/how-to-customize/DynamicCSSVariables.js"}}

### 覆盖主题

{{"demo": "pages/customization/how-to-customize/DynamicThemeNesting.js"}}

## 4、 全局化主题变体

In order to promote consistency between components, and manage the user interface appearance as a whole, MUI provides a mechanism to apply global changes.

Please take a look at the theme's [global overrides page](/customization/theme-components/) for more details.

## 5、 全局 CSS 覆盖

Components expose [global class names](/styles/advanced/#with-material-ui-core) to enable customization with CSS.

```css
.MuiButton-root {
  font-size: 1rem;
}
```

You can reference the [Styles library interoperability guide](/guides/interoperability/) to find examples of this using different styles libraries or plain CSS.

If you just want to add some global baseline styles for some of the HTML elements, you can use the `GlobalStyles` component. Here is an example of how you can override styles for the `h1` elements.

{{"demo": "pages/customization/how-to-customize/GlobalCssOverride.js", "iframe": true, "height": 100}}

If you are already using the [CssBaseline](/components/css-baseline/) component for setting baseline styles, you can also add these global styles as overrides for this component. Here is how you can achieve the same by using this approach.

{{"demo": "pages/customization/how-to-customize/OverrideCssBaseline.js", "iframe": true, "height": 100}}

> Note: It is a good practice to hoist the `<GlobalStyles />` to a static constant, to avoid rerendering. This will ensure that the `<style>` tag generated would not recalculate on each render.

```diff
 import * as React from 'react';
 import GlobalStyles from '@mui/material/GlobalStyles';

+const inputGlobalStyles = <GlobalStyles styles={...} />;

 const Input = (props) => {
   return (
     <React.Fragment>
-      <GlobalStyles styles={...} />
+      {inputGlobalStyles}
       <input {...props} />
     </React.Fragment>
   )
 }
```

## 6. Custom class name

Check out [ClassName Generator](/guides/classname-generator/) section for more details.
